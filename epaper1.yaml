esphome:
  name: epaper1
  friendly_name: epaper1
  
  on_boot:
    then:
      - delay: 3s
      - lambda: |-
          ESP_LOGI("main", "Boot sequence starting");
      - component.update: main_display

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:
  level: DEBUG
  baud_rate: 115200

api:
  encryption:
    key: "sptBK8w6ZAhtEPI/S5X7BuHFoLi7u6IqG6pJVPU9g3s="
  reboot_timeout: 0s
  on_client_connected:
    then:
      - lambda: |-
          ESP_LOGI("main", "API Connected to Home Assistant!");
          id(ha_connected) = true;
          id(force_display_update) = true;
  on_client_disconnected:
    then:
      - lambda: |-
          ESP_LOGW("main", "API Disconnected from Home Assistant");
          id(ha_connected) = false;
          id(force_display_update) = true;

ota:
  - platform: esphome
    password: "8b483b284d5c3ce12c98f7568297577b"

globals:
  - id: wifi_status
    type: int
    restore_value: no
    initial_value: "0"
  - id: recorded_display_refresh
    type: int
    restore_value: yes
    initial_value: '0'
  - id: last_refresh_time
    type: std::string
    restore_value: yes
    initial_value: '"Never"'
  - id: force_display_update
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: ha_connected
    type: bool
    restore_value: no
    initial_value: 'false'

time:
  - platform: sntp
    id: local_time
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
    timezone: "America/Chicago"
    on_time_sync:
      then:
        - lambda: |-
            ESP_LOGI("main", "Time synced");
            id(force_display_update) = true;

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Epaper1 Fallback Hotspot"
    password: "3DNTqSHQmojf"
  on_connect:
    then:
      - lambda: |-
          ESP_LOGI("main", "WiFi connected");
          id(force_display_update) = true;
  on_disconnect:
    then:
      - lambda: |-
          ESP_LOGE("main", "WiFi disconnected!");

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

font:
  - file: "gfonts://Roboto"
    id: font_large
    size: 96
  - file: "gfonts://Roboto"
    id: font_big
    size: 36
  - file: "gfonts://Roboto"
    id: font_medium
    size: 24
  - file: "gfonts://Roboto"
    id: font_small
    size: 12
  - file: "Roboto-Bold.ttf"
    id: roboto_bold_20
    size: 20

text_sensor:
  - platform: homeassistant
    id: meal_mon
    name: "Meal Monday"
    entity_id: input_text.meal_mon
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("main", "Meal Monday updated");
            id(force_display_update) = true;
            
  - platform: homeassistant
    id: meal_tue
    name: "Meal Tuesday"
    entity_id: input_text.meal_tue
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("main", "Meal Tuesday updated");
            id(force_display_update) = true;
            
  - platform: homeassistant
    id: meal_wed
    name: "Meal Wednesday"
    entity_id: input_text.meal_wed
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("main", "Meal Wednesday updated");
            id(force_display_update) = true;
            
  - platform: homeassistant
    id: meal_thu
    name: "Meal Thursday"
    entity_id: input_text.meal_thu
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("main", "Meal Thursday updated");
            id(force_display_update) = true;
            
  - platform: homeassistant
    id: meal_fri
    name: "Meal Friday"
    entity_id: input_text.meal_fri
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("main", "Meal Friday updated");
            id(force_display_update) = true;
            
  - platform: homeassistant
    id: meal_sat
    name: "Meal Saturday"
    entity_id: input_text.meal_sat
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("main", "Meal Saturday updated");
            id(force_display_update) = true;
            
  - platform: homeassistant
    id: meal_sun
    name: "Meal Sunday"
    entity_id: input_text.meal_sun
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("main", "Meal Sunday updated");
            id(force_display_update) = true;
            
  - platform: homeassistant
    id: meal_notes
    name: "Meal Notes"
    entity_id: input_text.meal_notes
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("main", "Meal Notes updated");
            id(force_display_update) = true;

  - platform: template
    name: 'Last Restart'
    icon: mdi:clock
    entity_category: diagnostic
    lambda: |-
      auto now = id(local_time).now();
      if (now.is_valid()) {
        return now.strftime("%Y-%m-%d %H:%M:%S");
      }
      return std::string("Time not available");

  - platform: template
    name: "Display Refresh Count"
    lambda: |-
      return to_string(id(recorded_display_refresh));

  - platform: template
    name: "Last Display Refresh"
    icon: mdi:update
    entity_category: diagnostic
    lambda: |-
      return id(last_refresh_time);

display:
  - platform: waveshare_epaper
    id: main_display
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin: GPIO4
    reset_pin: GPIO2
    model: 7.50inv2
    rotation: 0
    update_interval: 30s
    lambda: |-
      ESP_LOGD("display", "Starting display render");
      
      // Only update if forced or if we have data
      if (id(force_display_update) || id(ha_connected)) {
        id(recorded_display_refresh) += 1;
        
        auto now = id(local_time).now();
        if (now.is_valid()) {
          id(last_refresh_time) = now.strftime("%Y-%m-%d %H:%M:%S");
        } else {
          id(last_refresh_time) = "Time not available";
        }
        
        int cell_width = it.get_width() / 4;
        int cell_height = it.get_height() / 2;
        int max_content_width = cell_width - 10;  // 5px padding on each side
        
        // Draw grid lines
        for (int i = 1; i < 4; i++) {
          it.line(i * cell_width, 0, i * cell_width, it.get_height());
        }
        it.line(0, cell_height, it.get_width(), cell_height);
        
        const char* days[] = {"SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT", "NOTES"};
        
        for (int row = 0; row < 2; row++) {
          for (int col = 0; col < 4; col++) {
            int index = row * 4 + col;
            if (index >= 8) break;
            
            int x = col * cell_width + 5;
            int y = row * cell_height + 5;
            int content_y = y + 30;
            
            it.filled_rectangle(x-2, y-2, cell_width-6, 25, COLOR_ON);
            it.printf(x, y, id(roboto_bold_20), COLOR_OFF, TextAlign::TOP_LEFT, days[index]);
            
            std::string meal_text = "Loading...";
            
            switch (index) {
              case 0: meal_text = id(meal_sun).state; break;
              case 1: meal_text = id(meal_mon).state; break;
              case 2: meal_text = id(meal_tue).state; break;
              case 3: meal_text = id(meal_wed).state; break;
              case 4: meal_text = id(meal_thu).state; break;
              case 5: meal_text = id(meal_fri).state; break;
              case 6: meal_text = id(meal_sat).state; break;
              case 7: meal_text = id(meal_notes).state; break;
            }
            
            if (meal_text == "null" || meal_text.empty() || meal_text == "unavailable") {
              meal_text = "Loading...";
            }
            
            if (meal_text.length() >= 2 && meal_text.front() == '"' && meal_text.back() == '"') {
              meal_text = meal_text.substr(1, meal_text.length() - 2);
            }
            
            // Simple word wrap function without stringstream
            auto wrap_text_at_spaces = [](const std::string& text, int max_chars) -> std::vector<std::string> {
              std::vector<std::string> lines;
              std::vector<std::string> words;
              
              // Split text into words manually
              std::string word;
              for (char c : text) {
                if (c == ' ') {
                  if (!word.empty()) {
                    words.push_back(word);
                    word.clear();
                  }
                } else {
                  word.push_back(c);
                }
              }
              if (!word.empty()) {
                words.push_back(word);
              }
              
              // Build lines from words
              std::string current_line;
              for (const std::string& w : words) {
                if (current_line.empty()) {
                  current_line = w;
                } else if (current_line.length() + 1 + w.length() <= max_chars) {
                  current_line += " " + w;
                } else {
                  lines.push_back(current_line);
                  current_line = w;
                }
                
                // Limit to reasonable number of lines
                if (lines.size() >= 5) {
                  // Add ellipsis to last line if we have more words
                  if (current_line.length() > 3) {
                    current_line = current_line.substr(0, current_line.length() - 3) + "...";
                  }
                  lines.push_back(current_line);
                  break;
                }
              }
              
              if (!current_line.empty() && lines.size() < 6) {
                lines.push_back(current_line);
              }
              
              return lines;
            };
            
            // Calculate available lines based on cell height
            int available_height = cell_height - (content_y - y) - 5; // 5px bottom margin
            int line_height = 20; // font_medium is 24px, use 20 spacing
            int max_lines = available_height / line_height;
            
            // Use consistent font_medium for all text
            int max_chars_per_line = 14;
            
            std::vector<std::string> lines = wrap_text_at_spaces(meal_text, max_chars_per_line);
            
            // If lines exceed available space, limit them
            if (lines.size() > max_lines && max_lines > 0) {
              lines.resize(max_lines);
              // Add ellipsis to last line if it was truncated
              if (!lines.empty() && lines.back().length() > 3) {
                lines.back() = lines.back().substr(0, lines.back().length() - 3) + "...";
              }
            }
            
            // Draw all lines with consistent font_medium
            for (size_t i = 0; i < lines.size(); i++) {
              int line_y = content_y + (i * line_height);
              it.printf(x, line_y, id(font_medium), COLOR_ON, TextAlign::TOP_LEFT, lines[i].c_str());
            }
            
            // If no lines were generated (empty text), show "Loading..."
            if (lines.empty()) {
              it.printf(x, content_y, id(font_medium), COLOR_ON, TextAlign::TOP_LEFT, "Loading...");
            }
          }
        }

        it.printf(5, it.get_height() - 30, id(font_small), COLOR_ON, TextAlign::TOP_LEFT, 
                  "Refresh: %d", id(recorded_display_refresh));
        
        auto now_time = id(local_time).now();
        if (now_time.is_valid()) {
          it.printf(5, it.get_height() - 15, id(font_small), COLOR_ON, TextAlign::TOP_LEFT,
                    "%s", now_time.strftime("%H:%M").c_str());
        }
        
        id(force_display_update) = false;
        ESP_LOGI("main", "Display refresh completed. Refreshes: %d", id(recorded_display_refresh));
      } else {
        ESP_LOGD("display", "Skipping display update, not forced and HA not connected");
      }

interval:
  - interval: 30s
    then:
      - lambda: |-
          ESP_LOGI("main", "Status check - Refreshes: %d, Force update: %s", 
                   id(recorded_display_refresh),
                   id(force_display_update) ? "true" : "false");

sensor:
  - platform: wifi_signal
    id: wifi_signal_sensor
    name: "WiFi Signal Sensor"
    update_interval: 30s

  - platform: uptime
    id: uptime_sensor
    name: "Uptime Seconds"
    update_interval: 10s

  - platform: uptime
    name: "Uptime"

button:
  - platform: restart
    name: "Restart Device"
    
  - platform: template
    name: "Refresh Display Now"
    icon: mdi:refresh
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("main", "Manual display refresh triggered");
            id(force_display_update) = true;
        - component.update: main_display

binary_sensor:
  - platform: status
    name: "Status"
    entity_category: diagnostic

web_server:
  port: 80
  include_internal: true
  version: 3

captive_portal:
