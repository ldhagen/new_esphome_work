esphome:
  name: epaper1
  friendly_name: epaper1

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "sptBK8w6ZAhtEPI/S5X7BuHFoLi7u6IqG6pJVPU9g3s="

ota:
  - platform: esphome
    password: "8b483b284d5c3ce12c98f7568297577b"

globals:
  - id: wifi_status
    type: int
    restore_value: no
    initial_value: "0"
  - id: recorded_display_refresh
    type: int
    restore_value: yes
    initial_value: '0'
  - id: last_refresh_time
    type: std::string
    restore_value: yes
    initial_value: '"Never"'

#time:
  #- platform: homeassistant
  #  id: homeassistant_time
time:
  - platform: sntp
    id: local_time
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
    timezone: "America/Chicago"  # Adjust for your timezone
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Epaper1 Fallback Hotspot"
    password: "3DNTqSHQmojf"

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

# Add image component
image:
  - file: "grayParis.png"
    id: paris_image
    type: grayscale
    resize: 600x400  # Adjust if needed to match your display resolution

font:
  - file: "gfonts://Roboto"
    id: font_large
    size: 96
  - file: "gfonts://Roboto"
    id: font_medium
    size: 16
  - file: "gfonts://Roboto"
    id: font_small
    size: 12
  - file: "Roboto-Bold.ttf"
    id: roboto_bold_20  # Give your font a unique ID
    size: 20

    

display:
  - platform: waveshare_epaper
    id: main_display
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin: GPIO4
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: 600s
    rotation: 0
    lambda: |-
      // Increment refresh counter
      id(recorded_display_refresh) += 1;
      
      // Update last refresh time
      //auto now = id(homeassistant_time).now();
      auto now = id(local_time).now();
      if (now.is_valid()) {
        id(last_refresh_time) = now.strftime("%Y-%m-%d %H:%M:%S");
      } else {
        id(last_refresh_time) = "Time not available";
      }
      
      // Display the Paris image
      //it.image(0, 0, id(paris_image));
      
      // Optional: You can still add text on top of the image if desired
      // it.printf(10, 10, id(font_large), "Lance Rules!");

       // Grid dimensions for 4x2 layout
      int cell_width = it.get_width() / 4;    // 200px each
      int cell_height = it.get_height() / 2;  // 200px each
      
      // Draw grid lines
      for (int i = 1; i < 4; i++) {
        it.line(i * cell_width, 0, i * cell_width, it.get_height());
      }
      it.line(0, cell_height, it.get_width(), cell_height);
      
      // Day names
      const char* days[] = {"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN", "NOTES"};
            
      for (int row = 0; row < 2; row++) {
        for (int col = 0; col < 4; col++) {
          int index = row * 4 + col;
          if (index >= 8) break;
          
          int x = col * cell_width + 5;
          int y = row * cell_height + 5;
          int content_y = y + 30;
          
          // Day header background
          it.filled_rectangle(x-2, y-2, cell_width-6, 25, COLOR_ON);
          
          // Day name (white text on black)
          it.printf(x, y, id(roboto_bold_20), COLOR_OFF, TextAlign::TOP_LEFT, days[index]);
        }
      }




sensor:
  - platform: wifi_signal
    name: "WiFi Signal Sensor"
    update_interval: 60s

  - platform: uptime
    name: "Uptime Seconds"

  - platform: uptime
    name: "Uptime"

  - platform: internal_temperature
    name: "Internal Temperature"
  
  
  - platform: adc
    pin: GPIO0  # Verify this is the correct ADC pin for your board
    name: "Battery Voltage"
    id: battery_voltage
    unit_of_measurement: "V"
    update_interval: 60s
    filters:
      - multiply: 2.0  # Start with this - you'll need to calibrate based on your voltage divider
      - offset: 0.0    # Add if needed for calibration
    accuracy_decimals: 2
    entity_category: diagnostic
    icon: "mdi:battery"
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("battery", "Raw voltage: %.2fV", x);

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    update_interval: 60s
    lambda: |-
      if (!id(battery_voltage).has_state()) {
        return NAN;
      }
      
      float voltage = id(battery_voltage).state;
      
      // LiPo battery voltage characteristics
      float min_voltage = 3.2;   // 0% - battery cutoff
      float max_voltage = 4.2;   // 100% - fully charged
      
      // Handle out-of-range values
      if (voltage <= min_voltage) return 0.0;
      if (voltage >= max_voltage) return 100.0;
      
      // More accurate LiPo discharge curve approximation
      float percentage = (voltage - min_voltage) / (max_voltage - min_voltage) * 100.0;
      
      // Optional: Add non-linear correction for better accuracy
      if (percentage > 100.0) percentage = 100.0;
      if (percentage < 0.0) percentage = 0.0;
      
      return percentage;
    filters:
      - round: 1
    entity_category: diagnostic
    icon: "mdi:battery"
text_sensor:
  - platform: version
    name: "ESPHome Version"

  - platform: template
    name: 'Last Restart'
    icon: mdi:clock
    entity_category: diagnostic

  - platform: template
    name: "Display Refresh Count"
    lambda: |-
      return to_string(id(recorded_display_refresh));

  - platform: template
    name: "Last Display Refresh"
    icon: mdi:update
    entity_category: diagnostic
    lambda: |-
      return id(last_refresh_time);
      

web_server:
  port: 80
  include_internal: True
  version: 3

captive_portal:

#deep_sleep:
# id: deep_sleep_1
# run_duration: 5min
# sleep_duration: 30min
