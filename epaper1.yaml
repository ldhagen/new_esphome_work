esphome:
  name: epaper1
  friendly_name: epaper1

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:
  level: VERBOSE

api:
  encryption:
    key: "sptBK8w6ZAhtEPI/S5X7BuHFoLi7u6IqG6pJVPU9g3s="
  services:
    - service: refresh_display
      then:
        - component.update: main_display
        - lambda: |-
            ESP_LOGI("main", "Manual display refresh triggered");


ota:
  - platform: esphome
    password: "8b483b284d5c3ce12c98f7568297577b"

globals:
  - id: wifi_status
    type: int
    restore_value: no
    initial_value: "0"
  - id: recorded_display_refresh
    type: int
    restore_value: yes
    initial_value: '0'
  - id: last_refresh_time
    type: std::string
    restore_value: yes
    initial_value: '"Never"'
  - id: deep_sleep_duration_minutes
    type: int
    restore_value: yes
    initial_value: '30'
  - id: deep_sleep_pending
    type: bool
    restore_value: no
    initial_value: 'false'

time:
  - platform: sntp
    id: local_time
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
    timezone: "America/Chicago"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Epaper1 Fallback Hotspot"
    password: "3DNTqSHQmojf"

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

font:
  - file: "gfonts://Roboto"
    id: font_large
    size: 96
  - file: "gfonts://Roboto"
    id: font_medium
    size: 16
  - file: "gfonts://Roboto"
    id: font_small
    size: 12
  - file: "Roboto-Bold.ttf"
    id: roboto_bold_20
    size: 20

    

display:
  - platform: waveshare_epaper
    id: main_display
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin: GPIO4
    reset_pin: GPIO1
    model: 7.50inv2
    update_interval: 30s
    rotation: 0
    lambda: |-
      // Increment refresh counter
      id(recorded_display_refresh) += 1;
      
      // Update last refresh time
      auto now = id(local_time).now();
      if (now.is_valid()) {
        id(last_refresh_time) = now.strftime("%Y-%m-%d %H:%M:%S");
      } else {
        id(last_refresh_time) = "Time not available";
      }
      
      // Grid dimensions for 4x2 layout
      int cell_width = it.get_width() / 4;
      int cell_height = it.get_height() / 2;
      
      // Draw grid lines
      for (int i = 1; i < 4; i++) {
        it.line(i * cell_width, 0, i * cell_width, it.get_height());
      }
      it.line(0, cell_height, it.get_width(), cell_height);
      
      // Day names and meals
      const char* days[] = {"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN", "NOTES"};
      const char* meal_ids[] = {
        "meal_mon", "meal_tue", "meal_wed", "meal_thu", 
        "meal_fri", "meal_sat", "meal_sun", "meal_notes"
      };
            
      for (int row = 0; row < 2; row++) {
        for (int col = 0; col < 4; col++) {
          int index = row * 4 + col;
          if (index >= 8) break;
          
          int x = col * cell_width + 5;
          int y = row * cell_height + 5;
          int content_y = y + 30;
          
          // Day header background
          it.filled_rectangle(x-2, y-2, cell_width-6, 25, COLOR_ON);
          
          // Day name (white text on black)
          it.printf(x, y, id(roboto_bold_20), COLOR_OFF, TextAlign::TOP_LEFT, days[index]);
          
          // Get meal text - handle potential null states
          std::string meal_text = "Loading...";
          switch (index) {
            case 0:
              if (id(meal_mon).has_state()) meal_text = id(meal_mon).state;
              break;
            case 1:
              if (id(meal_tue).has_state()) meal_text = id(meal_tue).state;
              break;
            case 2:
              if (id(meal_wed).has_state()) meal_text = id(meal_wed).state;
              break;
            case 3:
              if (id(meal_thu).has_state()) meal_text = id(meal_thu).state;
              break;
            case 4:
              if (id(meal_fri).has_state()) meal_text = id(meal_fri).state;
              break;
            case 5:
              if (id(meal_sat).has_state()) meal_text = id(meal_sat).state;
              break;
            case 6:
              if (id(meal_sun).has_state()) meal_text = id(meal_sun).state;
              break;
            case 7:
              if (id(meal_notes).has_state()) meal_text = id(meal_notes).state;
              break;
          }
          
          // Clean up meal text - remove any extra quotes or spaces
          if (meal_text == "null" || meal_text.empty()) {
            meal_text = "   ";
          }
          
          // Remove surrounding quotes if present
          if (meal_text.length() >= 2 && meal_text.front() == '"' && meal_text.back() == '"') {
            meal_text = meal_text.substr(1, meal_text.length() - 2);
          }
          
          // Display meal text with wrapping
          int max_chars_per_line = 18;
          if (meal_text.length() <= max_chars_per_line) {
            // Single line
            it.printf(x, content_y, id(font_medium), COLOR_ON, TextAlign::TOP_LEFT, meal_text.c_str());
          } else {
            // Two lines - find a good break point
            int break_point = max_chars_per_line;
            for (int i = max_chars_per_line; i > max_chars_per_line - 8; i--) {
              if (i < meal_text.length() && meal_text[i] == ' ') {
                break_point = i;
                break;
              }
            }
            
            std::string line1 = meal_text.substr(0, break_point);
            std::string line2 = meal_text.substr(break_point + 1);
            
            // Trim whitespace
            while (!line1.empty() && line1.back() == ' ') line1.pop_back();
            while (!line2.empty() && line2.front() == ' ') line2 = line2.substr(1);
            
            it.printf(x, content_y, id(font_small), COLOR_ON, TextAlign::TOP_LEFT, line1.c_str());
            if (!line2.empty()) {
              it.printf(x, content_y + 15, id(font_small), COLOR_ON, TextAlign::TOP_LEFT, line2.c_str());
            }
          }
        }
      }


      // Debug info (small text at bottom)
      it.printf(5, it.get_height() - 15, id(font_small), COLOR_ON, TextAlign::TOP_LEFT, 
                "Refresh: %d", id(recorded_display_refresh));



interval:  
  - interval: 30s
    then:
      - lambda: |-
          ESP_LOGD("main", "Meal MON: %s", id(meal_mon).state.c_str());

sensor:
  - platform: wifi_signal
    name: "WiFi Signal Sensor"
    update_interval: 60s

  - platform: uptime
    name: "Uptime Seconds"

  - platform: uptime
    name: "Uptime"

  - platform: internal_temperature
    name: "Internal Temperature"

text_sensor:
  - platform: template
    name: 'Last Restart'
    icon: mdi:clock
    entity_category: diagnostic
    lambda: |-
      auto now = id(local_time).now();
      if (now.is_valid()) {
        return now.strftime("%Y-%m-%d %H:%M:%S");
      }
      return std::string("Time not available");

  - platform: template
    name: "Display Refresh Count"
    lambda: |-
      return to_string(id(recorded_display_refresh));

  - platform: template
    name: "Last Display Refresh"
    icon: mdi:update
    entity_category: diagnostic
    lambda: |-
      return id(last_refresh_time);

  - platform: homeassistant
    id: todays_meal
    entity_id: sensor.todays_meal
    
  - platform: homeassistant  
    id: weekly_menu
    entity_id: sensor.weekly_menu

  - platform: homeassistant
    id: meal_mon
    entity_id: input_text.meal_mon
  - platform: homeassistant
    id: meal_tue
    entity_id: input_text.meal_tue
  - platform: homeassistant
    id: meal_wed
    entity_id: input_text.meal_wed
  - platform: homeassistant
    id: meal_thu
    entity_id: input_text.meal_thu
  - platform: homeassistant
    id: meal_fri
    entity_id: input_text.meal_fri
  - platform: homeassistant
    id: meal_sat
    entity_id: input_text.meal_sat
  - platform: homeassistant
    id: meal_sun
    entity_id: input_text.meal_sun
  - platform: homeassistant
    id: meal_notes
    entity_id: input_text.meal_notes



button:
  - platform: restart
    name: "Restart Device"
    
  - platform: safe_mode
    name: "Restart in Safe Mode"
    

binary_sensor:
  - platform: status
    name: "Status"
    entity_category: diagnostic

# Web Server Configuration - Basic version
web_server:
  port: 80
  include_internal: true
  version: 3

captive_portal: